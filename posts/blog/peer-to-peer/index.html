<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Nikita Galaiko"><link rel="shortcut icon" href=https://galaiko.rocks/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Building a peer to peer messenger</title></head><body><header id=banner><h2><a href=https://galaiko.rocks>Nikita Galaiko</a></h2><nav><ul><li><a href=/posts/ title>Posts</a></li><li><a href=/about/ title>About</a></li><li><a href=/posts/index.xml title>RSS</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Building a peer to peer messenger</h1><div><time>March 20, 2019</time></div></header><p><img src=/media/p2p/p2p.jpg alt></p><p>The idea of a peer to peer <strong>something</strong> is to create a system that doesn&rsquo;t require any centralized server to
operate. In the case of a messenger, two users should be able to communicate directly between each other until at
least one of their instances is running.</p><p>That&rsquo;s why the most important part of such systems is a discovery. If peers can&rsquo;t find each other, it&rsquo;s useless.</p><p>The first problem is to build a messenger app, that can discover the same apps in the network and securely
communicate with each other.</p><p>The second problem is to allow regular people (<strong>non-programmers</strong>) to use it. As I can see, there are two ways
here. First is to build a mobile app and discover peers via Bluetooth or WiFi, plus have some bridge that allows
joining two local networks together via the internet.</p><p>I chose another way. Instead, there is a command line app for usage within the same network. And a dispatcher app
which purpose is to manage a cloud with dockerized peers and create a new instance for every user that needs it.</p><ol><li>User goes to a dispatcher webpage and clicks <strong>Login</strong></li><li>Dispatcher creates a new peer in a docker container and redirects the user to it</li></ol><p>I don&rsquo;t think that this approach is super scalable and makes sense in the real world; it requires too many
resources for a single user. But I have chosen it because it is more fun to implement for me as it needs more
infrastructure work.</p><p><img src=/media/p2p/cloud.jpg alt=cloud></p><h2 id=peer>Peer</h2><h3 id=communication>Communication</h3><p>Peers use <a href=https://grpc.io/>gRPC</a> to communicate with each other. It has a few benefits:</p><ol><li>There is a well defined <a href=https://github.com/ngalayko/p2p/tree/master/instance/messages/proto>.proto</a> API
schema. So it shouldn&rsquo;t be a problem to build clients using other programming languages.</li><li>Stream support. Peers can exchange messages over a single TCP connection (thanks to HTTP/2). There is also
ongoing work on supporting UDP as a transport. Initially, I wanted to use UDP based communication with QUIC
but decided to go with gRPC because of other features.</li><li>Small things like TLS, custom resolvers, compression, schema versioning, binary marshaling out of the box.</li></ol><p>Overall communication scenario between two peers looks like this:</p><ol><li>Check if there is an open stream connection to the peer<ul><li>If it exists, send a message using the connection</li></ul></li><li>Exchange public keys with a peer using an insecure connection</li><li>Open a secure stream connection to the peer and send a message.</li></ol><h2 id=discovery>Discovery</h2><p>In general, discovery is used to find other peers in the network. Discovery message contains name, id, ports,
address and a list of known peers. Public key not included in the discovery as it makes discovery message too big
to be transmitted via UDP multicast.</p><p>It also allows the peer to find its address by listening for its own announcement message.</p><p>UDP multicast discovery allows discovery within the same network. Perfect for standalone runs without docker.</p><p>Peers also can register itself in <a href=https://www.consul.io/>Consul</a> catalog and fetch information about other
peers from there. Perfect for dockerized runs inside docker swarm as it also can be used by
<a href=https://traefik.io/>Traefik</a> to automatically create routes for new peers and monitor their health.</p><h2 id=dispatcher>Dispatcher</h2><p>The goal of this service is to start a new peer by connecting to a docker swarm API, and redirect a user
to his peer instance.</p><p>Thanks to consul peers registration, it can fetch vacant peers directly from consul and use the information to
have a small buffer of unused peers. It is needed as a peer takes a few seconds to start and generate a
certificate.</p><p>The main logic for the service is relatively simple:</p><ol><li>Check if the user has an assigned peer (it is stored it his cookies)<ul><li>If it is there, redirect to the peer.</li></ul></li><li>Pop an unused peer from consul</li><li>Store its credentials in the user&rsquo;s session</li><li>Redirect the user to the peer.</li></ol><h2 id=bridge>Bridge</h2><p>This is not implemented part so far, but the idea is to create another app that has two parts: discovery and
proxy.</p><p>Two bridges in different networks, for example, a cloud network from the scheme above and a local network, should
connect and exchange information about known peers.</p><p>When a message is sent from peer in the one network to the peer in another, bridge acts as a gateway
and proxies the connection between two peers.</p><p>Final architecture:</p><p><img src=/media/p2p/bridge.jpg alt=bridge></p><p>You can find the code and maybe participate at <a href=https://github.com/ngalayko/p2p>github</a>.</p><h2 id=links>Links:</h2><ul><li><a href=https://p2p.galaiko.rocks>Messenger</a></li><li><a href=https://github.com/ngalayko/p2p>GitHub</a></li><li><a href=https://traefik.io/>Traefik</a></li><li><a href=https://www.consul.io/>Consul</a></li></ul></article></main><footer id=footer><style>a{color:inherit;text-decoration:none}a:hover{text-decoration:underline}</style>&copy; 2021
<a href=https://galaiko.rocks>Nikita Galaiko</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></footer></body></html>
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Nikita Galaiko"><title>Daily Coding Problem #15</title><link rel="shortcut icon" href=https://galaiko.rocks/favicon.ico><style>*,*:before,*:after{box-sizing:border-box}body{font-size:20px;line-height:28px;font-family:helvetica neue,arial,sans-serif;width:100%;margin:0 auto;padding:0 16px}@media(min-width:770px){body{width:800px}}header#banner{margin:25px 0}header#banner a{text-decoration:none}header#banner a:hover{text-decoration:underline}header#banner h2{display:inline;margin:0 8px 0 0;font-size:1em}header#banner nav{display:inline-block}header#banner nav ul{list-style-type:none;text-transform:lowercase;margin:0;padding:0}header#banner nav ul li{display:inline;margin:0 3px}main#content a{text-decoration:none}main#content a:hover{text-decoration:underline}main#content h1,main#content h2,main#content h3,main#content h4,main#content h5,main#content h6{margin-bottom:0}main#content h2{font-size:21.4px;line-height:28px;margin:28px 0 0}main#content h1+p,main#content h3+p,main#content h4+p,main#content h5+p,main#content h6+p{margin-top:5px}main#content p{margin:16px 0}main#content hr{height:1px;border:0}main#content ul#posts{list-style-type:none;margin-top:0;padding:0}main#content ul#posts li{margin:5px 0;padding:0}main#content ul#posts small{font-size:.8em;margin-left:10px}main#content ul#posts li a{text-decoration:none}main#content header#post-header h1{display:block;font-size:1.95552em;line-height:1.2141em}main#content header#post-header div{display:block;font-size:.7em;line-height:.9em}main#content img{max-width:100%;margin:0 auto}main#content figure{margin:16px 0}main#content figure img{display:block;max-width:100%;margin:0 auto}main#content figure figcaption{font-size:.92em;font-style:italic;line-height:22px;text-align:center;margin-top:6px;padding:0 10px}main#content figure figcaption h4{font-style:normal;display:inline;margin:0}main#content figure figcaption p{display:inline;margin:0;padding-left:8px}main#content blockquote{font-style:italic;margin-top:10px;margin-bottom:10px;margin-left:50px;padding-left:15px;border-left:3px solid #ccc}main#content code,main#content pre{font-family:menlo,monospace}main#content code{font-size:.87em;line-height:1.45em}main#content pre{display:block;overflow-x:auto;white-space:pre}main#content section.footnotes{font-size:.9em}footer#footer{margin:40px 0;font-size:.8em;font-weight:300}html{scrollbar-color:#6c6c6c #2e2e2e}body{color:#282828;background:#fbf1c7}header#banner a{color:#282828}header#banner nav ul li a{color:#504945}main#content a{color:#076678}main#content p{color:#3c3836}main#content hr{background:#d8d8d8}main#content ul#posts small{color:#7c6f64}main#content ul#posts li a:hover{color:#458588}main#content header#post-header div{color:#7c6f64}@media(prefers-color-scheme:dark){html{scrollbar-color:#6c6c6c #2e2e2e}body{color:#fbf1c7;background:#282828}header#banner a{color:#fbf1c7}header#banner nav ul li a{color:#d5c4a1}main#content a{color:#83a598}main#content p{color:#ebdbb2}main#content hr{background:#5c5c5c}main#content ul#posts small{color:#a89984}main#content ul#posts li a:hover{color:#458588}main#content header#post-header div{color:#a89984}}</style></head><body><header id=banner><h2><a href=https://galaiko.rocks>Nikita Galaiko</a></h2><nav><ul><li><a href=/posts/ title>Posts</a></li><li><a href=/about/ title>About</a></li><li><a href=/posts/index.xml title>RSS</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Daily Coding Problem #15</h1><div><time>July 16, 2018</time></div></header><p>Today problem is a <code>probability</code> problem.</p><h1 id=problem>Problem</h1><p>This problem was asked by Facebook.</p><p>Given a stream of elements too large to store in memory, pick a random element from the stream with uniform probability.</p><h1 id=solution>Solution</h1><p>There are many variations of such problems, and before solving it, I want to show some basic examples that I met.</p><p>Most trivial one is <strong>picking one random element from an array</strong>.</p><p>Every programming language has a function to generate a pseudo-random number (<code>int</code> or <code>float</code>) within the given range. If you think
of an array <strong>A</strong> as of <strong>N</strong> numbers, it&rsquo;s clear how to pick random one: generate number <strong>i</strong> from 0 to N, and <strong>a[i]</strong> is the answer.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>oneRandom</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>))</span>
    <span class=k>return</span> <span class=nx>aa</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>Sometimes you need to pick <strong>N random elements from an array</strong>.</p><p>In this case, you can use the same approach and pick <strong>N</strong> indexes from <strong>0</strong> to <strong>len(A)</strong>.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nRandom</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
    <span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>result</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nf>oneRandom</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>
</code></pre></div><p>However, if you need to pick <strong>N</strong> random elements, they also have to be <strong>different</strong>.</p><p>In this case, you can pick <strong>N</strong> different indexes and make sure that they are different:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nDifferentRandom1</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>{}</span>
    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span> <span class=o>!=</span> <span class=nx>n</span> <span class=p>{</span>
        <span class=nx>j</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>))</span>
        <span class=nx>m</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}</span>

    <span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
        <span class=nx>result</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>
</code></pre></div><p>But itâ€™s not very efficient, because you can spend much time trying to pick the
last index when you need to pick 8 elements from an array of length 10.</p><p>In this case, you can use the well-known zero-allocation algorithm to do so.
The idea is to move elements you picked to the beginning of an array,
and choose from others next:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nDifferentRandom2</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>chooseFrom</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span>                            <span class=c1>// define a slice to pick from
</span><span class=c1></span>        <span class=nx>choosenIndex</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>chooseFrom</span><span class=p>))</span>     <span class=c1>// pick a random index from i to N
</span><span class=c1></span>        <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>choosenIndex</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>choosenIndex</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>  <span class=c1>// swap choosenElement with i
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// after all, we have choosen elements at the
</span><span class=c1></span>    <span class=c1>// begining of an array, and probability is always same.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>a</span><span class=p>[:</span><span class=nx>n</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>Let&rsquo;s return to problem #15 and try to solve it using previous examples.</p><p>What do we have:</p><ol><li>a stream of elements too large to store in memory</li><li>should pick 1 random element</li></ol><p>We understand that to pick a random element from the stream with uniform probability,
we need to process hole stream somehow (without storing to memory).</p><p>Well, we always can iterate over a stream (but just once).</p><p>If we knew the length of a stream, we could use the approach from the first example, that would be perfect.</p><p>In first example each element of an array have a linked number - it&rsquo;s index.
Moreover, we used a function that returns number from 0 to n with uniform probability within that range to pick one.</p><p>So, in this case, we can <strong>assign</strong> a random value to each element with the same probability, and choose between them based on it linked number.</p><p>Let&rsquo;s do it: for each element, we generate a float number between <strong>[0..1]</strong>. Also, we remember
maximum value that we generated, an element from the stream associated with it - random element.</p><h1 id=code>Code</h1><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>solution</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=nx>result</span> <span class=kt>int</span>
		<span class=kd>var</span> <span class=nx>lastprob</span> <span class=kt>float64</span>
		<span class=k>for</span> <span class=nx>a</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
			<span class=nx>prob</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span>
			<span class=k>if</span> <span class=nx>prob</span> <span class=p>&gt;</span> <span class=nx>lastprob</span> <span class=p>{</span>
				<span class=nx>result</span> <span class=p>=</span> <span class=nx>a</span>
				<span class=nx>lastprob</span> <span class=p>=</span> <span class=nx>prob</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>result</span>
	<span class=p>}()</span>
	<span class=k>return</span> <span class=nx>res</span>
<span class=p>}</span>
</code></pre></div><h1 id=links>Links</h1><p><a href=https://github.com/ngalayko/dcp/tree/master/problems/2018-07-16>github</a></p></article></main><footer id=footer><style>a{color:inherit;text-decoration:none}a:hover{text-decoration:underline}</style>&copy; 2018...2021
<a href=https://galaiko.rocks>Nikita Galaiko</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></footer></body></html>
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Nikita Galaiko"><link rel="shortcut icon" href=https://galaiko.rocks/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Daily Coding Problem #15</title></head><body><header id=banner><h2><a href=https://galaiko.rocks>Nikita Galaiko</a></h2><nav><ul><li><a href=/posts/ title>Posts</a></li><li><a href=/about/ title>About</a></li><li><a href=/posts/index.xml title>RSS</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Daily Coding Problem #15</h1><div><time>July 16, 2018</time></div></header><p>Today problem is a <code>probability</code> problem.</p><h1 id=problem>Problem</h1><p>This problem was asked by Facebook.</p><p>Given a stream of elements too large to store in memory, pick a random element from the stream with uniform probability.</p><h1 id=solution>Solution</h1><p>There are many variations of such problems, and before solving it, I want to show some basic examples that I met.</p><p>Most trivial one is <strong>picking one random element from an array</strong>.</p><p>Every programming language has a function to generate a pseudo-random number (<code>int</code> or <code>float</code>) within the given range. If you think
of an array <strong>A</strong> as of <strong>N</strong> numbers, it&rsquo;s clear how to pick random one: generate number <strong>i</strong> from 0 to N, and <strong>a[i]</strong> is the answer.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>oneRandom</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
    <span class=nx>i</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>))</span>
    <span class=k>return</span> <span class=nx>aa</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>Sometimes you need to pick <strong>N random elements from an array</strong>.</p><p>In this case, you can use the same approach and pick <strong>N</strong> indexes from <strong>0</strong> to <strong>len(A)</strong>.</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nRandom</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
    <span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>result</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nf>oneRandom</span><span class=p>(</span><span class=nx>a</span><span class=p>)</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>
</code></pre></div><p>However, if you need to pick <strong>N</strong> random elements, they also have to be <strong>different</strong>.</p><p>In this case, you can pick <strong>N</strong> different indexes and make sure that they are different:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nDifferentRandom1</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span> <span class=p>{</span>
    <span class=nx>m</span> <span class=o>:=</span> <span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>bool</span><span class=p>{}</span>
    <span class=k>for</span> <span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>)</span> <span class=o>!=</span> <span class=nx>n</span> <span class=p>{</span>
        <span class=nx>j</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>a</span><span class=p>))</span>
        <span class=nx>m</span><span class=p>[</span><span class=nx>j</span><span class=p>]</span> <span class=p>=</span> <span class=kc>true</span>
    <span class=p>}</span>

    <span class=nx>result</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span><span class=p>)</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>m</span> <span class=p>{</span>
        <span class=nx>result</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=nx>result</span>
<span class=p>}</span>
</code></pre></div><p>But itâ€™s not very efficient, because you can spend much time trying to pick the
last index when you need to pick 8 elements from an array of length 10.</p><p>In this case, you can use the well-known zero-allocation algorithm to do so.
The idea is to move elements you picked to the beginning of an array,
and choose from others next:</p><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>nDifferentRandom2</span><span class=p>(</span><span class=nx>a</span> <span class=p>[]</span><span class=kt>int</span><span class=p>,</span> <span class=nx>n</span> <span class=kt>int</span><span class=p>)</span> <span class=p>[]</span><span class=kt>int</span><span class=p>{</span>
    <span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=nx>n</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
        <span class=nx>chooseFrom</span> <span class=o>:=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>:]</span>                            <span class=c1>// define a slice to pick from
</span><span class=c1></span>        <span class=nx>choosenIndex</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Intn</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>chooseFrom</span><span class=p>))</span>     <span class=c1>// pick a random index from i to N
</span><span class=c1></span>        <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>choosenIndex</span><span class=p>]</span> <span class=p>=</span> <span class=nx>a</span><span class=p>[</span><span class=nx>choosenIndex</span><span class=p>],</span> <span class=nx>a</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span>  <span class=c1>// swap choosenElement with i
</span><span class=c1></span>    <span class=p>}</span>
    <span class=c1>// after all, we have choosen elements at the
</span><span class=c1></span>    <span class=c1>// begining of an array, and probability is always same.
</span><span class=c1></span>    <span class=k>return</span> <span class=nx>a</span><span class=p>[:</span><span class=nx>n</span><span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>Let&rsquo;s return to problem #15 and try to solve it using previous examples.</p><p>What do we have:</p><ol><li>a stream of elements too large to store in memory</li><li>should pick 1 random element</li></ol><p>We understand that to pick a random element from the stream with uniform probability,
we need to process hole stream somehow (without storing to memory).</p><p>Well, we always can iterate over a stream (but just once).</p><p>If we knew the length of a stream, we could use the approach from the first example, that would be perfect.</p><p>In first example each element of an array have a linked number - it&rsquo;s index.
Moreover, we used a function that returns number from 0 to n with uniform probability within that range to pick one.</p><p>So, in this case, we can <strong>assign</strong> a random value to each element with the same probability, and choose between them based on it linked number.</p><p>Let&rsquo;s do it: for each element, we generate a float number between <strong>[0..1]</strong>. Also, we remember
maximum value that we generated, an element from the stream associated with it - random element.</p><h1 id=code>Code</h1><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>solution</span><span class=p>(</span><span class=nx>in</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>)</span> <span class=o>&lt;-</span><span class=kd>chan</span> <span class=kt>int</span> <span class=p>{</span>
	<span class=nx>res</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>chan</span> <span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=p>)</span>
	<span class=k>go</span> <span class=kd>func</span><span class=p>()</span> <span class=p>{</span>
		<span class=kd>var</span> <span class=nx>result</span> <span class=kt>int</span>
		<span class=kd>var</span> <span class=nx>lastprob</span> <span class=kt>float64</span>
		<span class=k>for</span> <span class=nx>a</span> <span class=o>:=</span> <span class=k>range</span> <span class=nx>in</span> <span class=p>{</span>
			<span class=nx>prob</span> <span class=o>:=</span> <span class=nx>rand</span><span class=p>.</span><span class=nf>Float64</span><span class=p>()</span>
			<span class=k>if</span> <span class=nx>prob</span> <span class=p>&gt;</span> <span class=nx>lastprob</span> <span class=p>{</span>
				<span class=nx>result</span> <span class=p>=</span> <span class=nx>a</span>
				<span class=nx>lastprob</span> <span class=p>=</span> <span class=nx>prob</span>
			<span class=p>}</span>
		<span class=p>}</span>
		<span class=nx>res</span> <span class=o>&lt;-</span> <span class=nx>result</span>
	<span class=p>}()</span>
	<span class=k>return</span> <span class=nx>res</span>
<span class=p>}</span>
</code></pre></div><h1 id=links>Links</h1><p><a href=https://github.com/ngalayko/dcp/tree/master/problems/2018-07-16>github</a></p></article></main><footer id=footer><style>a{color:inherit;text-decoration:none}a:hover{text-decoration:underline}</style>&copy; 2021
<a href=https://galaiko.rocks>Nikita Galaiko</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></footer></body></html>
<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Nikita Galaiko"><link rel="shortcut icon" href=https://galaiko.rocks/favicon.ico><link rel=stylesheet href=/css/style.min.css><title>Daily Coding Problem: Problem #7</title></head><body><header id=banner><h2><a href=https://galaiko.rocks>Nikita Galaiko</a></h2><nav><ul><li><a href=/posts/ title>Posts</a></li><li><a href=/about/ title>About</a></li><li><a href=/index.xml title>RSS</a></li></ul></nav></header><main id=content><article><header id=post-header><h1>Daily Coding Problem: Problem #7</h1><div><time>July 8, 2018</time></div></header><h1 id=problem>Problem</h1><p>This problem was asked by Facebook.</p><p>Given the mapping a = 1, b = 2, &mldr; z = 26, and an encoded message, count the number of ways it can be decoded.</p><p>For example, the message &lsquo;111&rsquo; would give 3, since it could be decoded as &lsquo;aaa&rsquo;, &lsquo;ka&rsquo;, and &lsquo;ak&rsquo;.</p><p>You can assume that the messages are decodable. For example, &lsquo;001&rsquo; is not allowed.</p><h1 id=solution>Solution</h1><p>Firstly, let&rsquo;s take care of a mapping. So if <code>a = 1</code>, then <code>charCode = code(char) - code('a') + 1</code>,
it&rsquo;s is possible, because in ASCII table letters of Latin alphabet are located one by one.
In the example, I use function <code>f(string)</code> that returns 1 if a string can be decoded, otherwise 0.</p><p>Most of the string parsing problems are recursion based. To start with such a solution,
it&rsquo;s always helpful to manually solve some trivial cases, trying to use
the results of a previous case:</p><p>If the length of a string is 1, there is always 1 way to decode it, so it&rsquo;s our base case.</p><pre><code>'1':
    ['1']

----------
F('1') = 1
</code></pre><p>If the length is 2, we always have 1 way with all digits separately, plus one if a number is less than <code>26</code>,
we also use this one as a base case.</p><pre><code>'12':
    ['1', '2']
    ['12']
---------------------
F('12') = f('12') + 1
</code></pre><p>If the length is 3, we can use the results of previous calculations, because we already know how to
deal with shorter strings.</p><pre><code>F('123') = f('1') * F('23') + F('12') * f('3') = 3
</code></pre><p>All next cases can be calculated using previously defined:</p><pre><code>F('4123') = f('4') * F('123') + f('41') * F('23') = 3
</code></pre><h1 id=code>Code</h1><div class=highlight><pre class=chroma><code class=language-go data-lang=go><span class=kd>func</span> <span class=nf>solution</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
        <span class=nx>firstZero</span> <span class=o>:=</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span>
        <span class=nx>l</span> <span class=o>:=</span> <span class=nb>len</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
        <span class=k>switch</span> <span class=p>{</span>
        <span class=k>case</span> <span class=nx>l</span> <span class=o>==</span> <span class=mi>1</span><span class=p>:</span>
                <span class=k>return</span> <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
        <span class=k>case</span> <span class=nx>l</span> <span class=o>==</span> <span class=mi>2</span><span class=p>:</span>
                <span class=k>if</span> <span class=nx>firstZero</span> <span class=p>{</span>
                    <span class=c1>// endge case for strings like &#39;01&#39;
</span><span class=c1></span>                    <span class=k>return</span> <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span>
                <span class=p>}</span>
                <span class=k>return</span> <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span><span class=p>)</span> <span class=o>+</span> <span class=mi>1</span>
        <span class=k>default</span><span class=p>:</span>
                <span class=k>return</span> <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span><span class=p>[:</span><span class=mi>1</span><span class=p>])</span><span class=o>*</span><span class=nf>solution</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=mi>1</span><span class=p>:])</span> <span class=o>+</span>
                        <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span><span class=p>[:</span><span class=mi>2</span><span class=p>])</span><span class=o>*</span><span class=nf>solution</span><span class=p>(</span><span class=nx>s</span><span class=p>[</span><span class=mi>2</span><span class=p>:])</span>
        <span class=p>}</span>
<span class=p>}</span>

<span class=c1>// returns 1 if possible to decode string.
</span><span class=c1></span><span class=kd>func</span> <span class=nf>canDecode</span><span class=p>(</span><span class=nx>s</span> <span class=kt>string</span><span class=p>)</span> <span class=kt>int</span> <span class=p>{</span>
        <span class=k>if</span> <span class=nx>s</span><span class=p>[</span><span class=mi>0</span><span class=p>]</span> <span class=o>==</span> <span class=sc>&#39;0&#39;</span> <span class=p>{</span>
            <span class=k>return</span> <span class=mi>0</span>
        <span class=p>}</span>
        <span class=nx>i</span><span class=p>,</span> <span class=nx>err</span> <span class=o>:=</span> <span class=nx>strconv</span><span class=p>.</span><span class=nf>ParseInt</span><span class=p>(</span><span class=nx>s</span><span class=p>,</span> <span class=mi>10</span><span class=p>,</span> <span class=mi>64</span><span class=p>)</span>
        <span class=k>if</span> <span class=nx>err</span> <span class=o>!=</span> <span class=kc>nil</span> <span class=p>{</span>
                <span class=k>return</span> <span class=mi>0</span>
        <span class=p>}</span>
        <span class=k>if</span> <span class=nx>i</span> <span class=o>&gt;=</span> <span class=mi>0</span> <span class=o>&amp;&amp;</span> <span class=nx>i</span> <span class=o>&lt;=</span> <span class=mi>26</span> <span class=p>{</span>
                <span class=k>return</span> <span class=mi>1</span>
        <span class=p>}</span>
        <span class=k>return</span> <span class=mi>0</span>
<span class=p>}</span>
</code></pre></div><h1 id=links>Links</h1><p><a href=https://github.com/ngalayko/dcp/tree/master/problems/2018-07-08>github</a></p></article></main><footer id=footer><style>a{color:inherit;text-decoration:none}a:hover{text-decoration:underline}</style>&copy; 2021
<a href=https://galaiko.rocks>Nikita Galaiko</a>
&#183; <a href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank rel=noopener>CC BY-NC 4.0</a></footer></body></html>